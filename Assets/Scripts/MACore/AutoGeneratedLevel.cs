using System.Collections.Generic;
using UnityEngine;
using System;

namespace MACore
{
	public class AutoGeneratedLevel : Level
	{
		[HideInInspector]
		public float difficulty;
		private readonly float MAX_DIFFICULTY = 25.0f;
		
		/// <summary>
		/// Start this instance.
		/// </summary>
		public override void Start()
		{
			// Generate all the waves
			Generate();
			base.Start();
		}
		
		/// <summary>
		/// Generate this instance.
		/// </summary>
		private void Generate()
		{
			waves = new List<Wave>();
			difficulty = Mathf.Min(id/MAX_DIFFICULTY, 1);
			
			
			// Get the total number of waves
			float waveCount 	= 3 + difficulty*9;
			
			// First, determine the duration
			duration = 15 + (waveCount-2)*20;
			
			
			float diffPerWave 	= 1/MAX_DIFFICULTY/waveCount;
			
			float currentDifficulty = difficulty;
			for( int w=0;w<waveCount;w++ )
			{
				Wave wave = GenerateWave(w, waveCount, currentDifficulty);
				currentDifficulty	+= diffPerWave;
				currentDifficulty = Mathf.Min(1, currentDifficulty);
				
				waves.Add(wave);
			}
		}
		
		private Wave GenerateWave(int waveId, float waveCount, float difficulty)
		{
			Wave wave = new Wave();
			
			// The greater the difficulty, the bigger the monster
			wave.spawnTime 	= waveId/waveCount;
			//wave.type	

			wave.type			= GetMonsterType(wave.spawnTime, difficulty);
			wave.count			= GetMonsterCount(wave.type, difficulty);
			
			return wave;
		}
		
		private EMonsterType GetMonsterType(float percent, float difficulty)
		{
			// Number between 0 and 1
			float monsterId 	= Mathf.Abs(Mathf.Sin( percent * Mathf.PI/2));
			//EMonsterType type 	= (EMonsterType) Mathf.Round((monsterId * ((int)GetMaxMonster())));
			
			List<EMonsterType> types 	= GetPossibleMonsters();
			return types[ (int)Mathf.Round(monsterId* (types.Count-1))];
			
			//Debug.LogWarning("MonserId: " + monsterId + " Type: " + type );
			//return type;
		}
		
		/// <summary>
		/// Gets the biggest monster for this level
		/// </summary>
		/// <returns>
		/// The max monster.
		/// </returns>
		private EMonsterType GetMaxMonster()
		{
			// Get the max monster
			if( id < 3 )
				return EMonsterType.Weenie;
			
			if( id <= 8 )
				return EMonsterType.Vector;
			
			if( id <= 13 )
				return EMonsterType.Heap;
			
			return EMonsterType.Kobol;
		}
		
		private List<EMonsterType> GetPossibleMonsters()
		{
			List<EMonsterType> types = new List<EMonsterType>();
			
			// Get the max monster
			switch( id )
			{
				case 0:
				case 1:
				case 2:
					types.Add( EMonsterType.Weenie );
					break;

				case 3:
				case 4:
				case 5:
					types.Add( EMonsterType.Weenie );
					types.Add( EMonsterType.Vector );
					break;
				
				case 6:
				case 7:
					types.Add( EMonsterType.Weenie );
					types.Add( EMonsterType.Vector );
					types.Add( EMonsterType.VectorSentry );
					break;
				
				case 8:
				case 9:
					types.Add( EMonsterType.Weenie );
					types.Add( EMonsterType.Vector );
					types.Add( EMonsterType.Heap );
					break;
				
				case 10:
				case 11:
				case 12:
				case 13:
					types.Add( EMonsterType.VectorSentry );
					types.Add( EMonsterType.Vector );
					types.Add( EMonsterType.Heap );
					break;
				
				case 14:
				case 15:
				case 16:
					types.Add( EMonsterType.Vector );
					types.Add( EMonsterType.Heap );
					types.Add( EMonsterType.RocketHeap );
					break;
				
				case 17:
					types.Add( EMonsterType.VectorSentry );
					types.Add( EMonsterType.Heap );
					types.Add( EMonsterType.RocketHeap );
					break;				
				case 18:
				case 19:
				case 20:
					types.Add( EMonsterType.Heap );
					types.Add( EMonsterType.RocketHeap );
					types.Add( EMonsterType.Kobol );
					break;
				
				case 21:
				case 22:
				case 23:
					types.Add( EMonsterType.Kobol );
					types.Add( EMonsterType.BitBoss );
					break;
				
				case 24:
					types.Add( EMonsterType.Kobol );
					types.Add( EMonsterType.BitBoss );
					types.Add( EMonsterType.VectorBoss );
					break;
				
				case 25:
					types.Add( EMonsterType.Kobol );
					types.Add( EMonsterType.BitBoss );
					break;				
			}
			
			return types;
				
		}
		
		private int GetMonsterCount(EMonsterType type, float difficulty)
		{
			switch( type )
			{
				case EMonsterType.Weenie:
					return (int)Mathf.Round(3 + (difficulty*24));
				
				case EMonsterType.Vector:
					return (int)Mathf.Round(1 + (difficulty*12));
				
				case EMonsterType.VectorSentry:
				case EMonsterType.Heap:
				case EMonsterType.BitBoss:
					return (int)Mathf.Round(1 + (difficulty*6));
				
				case EMonsterType.RocketHeap:
				case EMonsterType.VectorBoss:
					return (int)Mathf.Round(1 + (difficulty*3));
				
				case EMonsterType.Kobol:
				return (int)Mathf.Round(1 + (difficulty*2));
			}
			return 1;
		}
		
		
		
	}
}

